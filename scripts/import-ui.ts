import * as nodefs from "node:fs"
import * as nodepath from "node:path"
import * as _ from "lodash-es"



const ENTRY = 'src/ui'
const ENTRY_ALIAS = '@/ui'
const IMPORTS_OUTPUT = 'src/ui.auto-imports.ts'

main()

function main()
{
    const paths: string[] = []

    searchFolder(paths, ENTRY, ENTRY)

    console.log('write ui imports from: ------------\n', paths)

    const import_statements: string[] = []
    const module_names: string[] = []

    paths.forEach((path) => {
        const waypoints = path.split('/')
        const module_name = _.flow(
            // 删除最后一个 index 路点 //
            (waypoints: string[]) => {
                return waypoints.at(-1) === 'index' ? waypoints.slice(0, waypoints.length - 1) : waypoints
            },
            // 转换写法到删除了引导前缀 View 的大驼峰形式 //
            (waypoints) => {
                return waypoints.map((waypoint) => _.camelCase(waypoint).slice(4))
            },
            // 拼接为单个字串 //
            (waypoints) => {
                return waypoints.join('_')
            },
        )(waypoints)

        module_names.push(module_name)
        import_statements.push(`import ${module_name} from "${ENTRY_ALIAS}/${path}.vue"`)
    })

    const export_statements =
    [
        'export default {',
        ...module_names.map((module_name) => `    ${module_name},`),
        '}',
    ].join('\n')
    
    const content =
    [
        '// auto-generated by scripts/import-api //',
        '// @ts-nocheck', // 避免编译阶段路径别名被 ts 检查。
        ...import_statements,
        '', '', '',
        export_statements,
        '',
    ].join('\n')

    nodefs.writeFileSync(nodepath.join(nodepath.resolve(), IMPORTS_OUTPUT), content)
}

function match(filename: string)
{
    return (filename === 'index.vue' || filename.startsWith('view-') && filename.endsWith('.vue')) && !filename.includes(' ')
}

function normalizePath(path: string)
{
    let normalized = path

    normalized.replace(/\\/g, '/')

    return _.flow(
        // 统一使用正斜杠作为目录分隔符 //
        (path) => {
            return path.replace(/\\/g, '/')
        },
        // 删除文件名的后缀部分 //
        (path) => {
            const last_dot_index = path.lastIndexOf(".")
            return last_dot_index === -1 ? path : path.slice(0, last_dot_index)
        },
    )(path)
}

function searchFolder(paths: string[], entry: string, dir: string) {
    // 获取目录下的所有文件和子目录 //
    const items = nodefs.readdirSync(dir)

    items.forEach((item) => {
        const item_path = nodepath.join(dir, item)
        const item_path_relative = nodepath.relative(entry, item_path)

        // 如果是目录，则递归调用 //
        if (nodefs.statSync(item_path).isDirectory())
            searchFolder(paths, entry, item_path)
        else if (match(item))
            paths.push(normalizePath(item_path_relative))
    })
}

function toAliased(path: string, alias: [from: string, to: string])
{
    return path.startsWith(alias[0]) ? path.replace(alias[0], alias[1]) : path
}
